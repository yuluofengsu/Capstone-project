# 社区化图书共享与推荐平台 - 系统实现说明

**文档版本**：1.0  
**最后更新**：2026年2月23日  
**实现者**：Capstone Project Team  

---

## 目录

1. [系统实现概述](#系统实现概述)
2. [4.1 用户信息管理模块的实现](#41-用户信息管理模块的实现)
3. [4.2 图书信息管理模块的实现](#42-图书信息管理模块的实现)
4. [4.3 借阅管理模块的实现](#43-借阅管理模块的实现)
5. [4.4 社区互动模块的实现](#44-社区互动模块的实现)
6. [4.5 系统管理模块的实现](#45-系统管理模块的实现)

---

## 系统实现概述

本平台采用**前后端分离架构**进行实现，前端使用Vue 2.x框架，后端使用Django 4.1.4框架。系统通过RESTful API进行前后端通信，采用Token认证机制确保接口安全。所有数据操作均遵循CRUD规范，通过统一的错误处理机制返回标准化的API响应。

### 架构设计原则

- **前后端分离**：前端页面与后端接口完全分离，通过HTTP通信
- **Token认证**：使用Token机制实现无状态的身份验证
- **统一响应格式**：所有API返回统一的APIResponse格式
- **异常处理**：完整的异常捕获和错误信息反馈机制

---

# 4.1 用户信息管理模块的实现

用户信息管理模块主要用于管理用户的登录、个人信息修改、账号管理等操作，同时为管理员提供用户信息的管理功能。采用前后端分离的架构实现，前端调用后端API完成用户相关操作。

## 4.1.1 用户注册的实现

用户进入程序后，可以通过点击"注册"按钮进入注册页面。前端页面展示用户名/邮箱、密码、确认密码等输入框。用户填入相关信息后，点击"注册"按钮，前端将用户输入的信息封装成User对象，调用registerApi方法将数据以POST请求发送至后端。

**实现步骤**：

1. **前端注册请求**（client/src/api/index/user.js）：

```javascript
// 前端调用注册API
export const registerApi = function (data) {
  return axios({
    url: '/myapp/index/user/register',
    method: 'post',
    data: data  // 包含username、password、repassword
  })
}
```

2. **后端注册处理**（server/myapp/views/index/user.py）：

后端的registerUser方法接收前端传来的User对象，执行以下操作：
- 验证用户名、密码、确认密码不为空
- 检查两次密码输入是否一致
- 查询数据库检查用户名是否已存在
- 对密码进行MD5加密处理
- 创建新用户记录

```python
@api_view(['POST'])
def register(request):
    # 获取请求参数
    username = request.data.get('username', None)
    password = request.data.get('password', None)
    repassword = request.data.get('repassword', None)
    
    # 参数验证
    if not username or not password or not repassword:
        return APIResponse(code=1, msg='用户名或密码不能为空')
    if password != repassword:
        return APIResponse(code=1, msg='密码不一致')
    
    # 检查用户名唯一性
    users = User.objects.filter(username=username)
    if len(users) > 0:
        return APIResponse(code=1, msg='该用户名已存在')
    
    # 创建用户
    data = {
        'username': username,
        'password': utils.md5value(password),  # MD5加密
        'role': 2,  # 普通用户角色
        'status': 0,  # 账号正常状态
    }
    serializer = UserSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='创建成功', data=serializer.data)
    
    return APIResponse(code=1, msg='创建失败')
```

**业务逻辑流程**：

```
用户输入 → 前端验证 → 调用registerApi → 后端验证参数 → 检查用户名唯一性 
→ MD5加密密码 → 保存到数据库 → 返回成功响应
```

3. **数据模型**（server/myapp/models.py）：

```python
class User(models.Model):
    ROLE_CHOICES = (
        ('0', '管理员'),
        ('1', '普通用户'),
        ('2', '演示用户'),
    )
    STATUS_CHOICES = (
        ('0', '正常'),
        ('1', '封号'),
    )
    
    id = models.BigAutoField(primary_key=True)
    username = models.CharField(max_length=50, null=True)  # 用户名/邮箱
    password = models.CharField(max_length=50, null=True)  # MD5加密密码
    role = models.CharField(max_length=2, blank=True, null=True)  # 用户角色
    status = models.CharField(max_length=1, choices=STATUS_CHOICES, default='0')  # 账号状态
    nickname = models.CharField(blank=True, null=True, max_length=20)  # 昵称
    avatar = models.FileField(upload_to='avatar/', null=True)  # 头像
    mobile = models.CharField(max_length=13, blank=True, null=True)  # 手机号
    email = models.CharField(max_length=50, blank=True, null=True)  # 邮箱
    gender = models.CharField(max_length=1, blank=True, null=True)  # 性别
    description = models.TextField(max_length=200, null=True)  # 个人简介
    create_time = models.DateTimeField(auto_now_add=True, null=True)  # 创建时间
    score = models.IntegerField(default=0, blank=True, null=True)  # 用户积分
    token = models.CharField(max_length=32, blank=True, null=True)  # 前台token
    admin_token = models.CharField(max_length=32, blank=True, null=True)  # 后台token
    
    class Meta:
        db_table = "b_user"
```

## 4.1.2 用户登录的实现

用户进入程序后，界面会提示登录。用户输入用户名和密码后点击"登录"按钮，前端调用loginApi方法，将用户名和密码发送到后端。后端的login方法接收用户名和密码，进行验证并生成Token。

**实现步骤**：

1. **前端登录请求**（client/src/api/index/user.js）：

```javascript
// 前端调用登录API
export const loginApi = function (data) {
  return axios({
    url: '/myapp/index/user/login',
    method: 'post',
    data: data  // 包含username、password
  })
}
```

2. **后端登录处理**（server/myapp/views/index/user.py）：

后端的login方法接收用户名和密码，执行以下操作：
- 对输入的密码进行MD5加密
- 查询数据库验证用户名和密码是否匹配
- 验证用户角色是否为前台用户（非管理员）
- 生成Token并保存到数据库
- 创建登录日志记录

```python
@api_view(['POST'])
def login(request):
    username = request.data['username']
    password = utils.md5value(request.data['password'])  # MD5加密

    # 查询用户
    users = User.objects.filter(username=username, password=password)
    if len(users) > 0:
        user = users[0]
        
        # 检查用户角色，防止后台管理员使用前台登录
        if user.role in ['1', '3']:
            return APIResponse(code=1, msg='该帐号为后台管理员帐号')
        
        # 检查账号状态
        if user.status == '1':
            return APIResponse(code=1, msg='该账号已被冻结')
        
        # 生成Token
        data = {
            'username': username,
            'password': password,
            'token': md5value(username)  # 使用用户名生成Token
        }
        
        # 保存Token到数据库
        serializer = UserSerializer(user, data=data)
        if serializer.is_valid():
            serializer.save()
            
            # 创建登录日志
            make_login_log(request)
            
            return APIResponse(code=0, msg='登录成功', data=serializer.data)

    return APIResponse(code=1, msg='用户名或密码错误')


def make_login_log(request):
    """创建登录日志记录"""
    try:
        username = request.data['username']
        data = {
            "username": username,
            "ip": utils.get_ip(request),  # 获取客户端IP
            "ua": utils.get_ua(request)   # 获取User-Agent信息
        }
        serializer = LoginLogSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
    except Exception as e:
        print(e)
```

**登录功能时序图**：

```
用户输入用户名/密码
    ↓
前端调用loginApi
    ↓
后端接收login请求
    ↓
MD5加密密码 → 查询用户
    ↓
验证用户名密码 ← 验证用户角色 ← 检查账号状态
    ↓
生成Token并保存 → 创建登录日志
    ↓
返回用户信息和Token给前端
    ↓
前端保存Token到localStorage
    ↓
跳转到首页
```

3. **Token管理**（client/src/store/modules/user.js）：

前端登录成功后，将返回的Token保存到Vuex状态管理和本地存储中，后续所有请求都会在请求头中带上Token进行身份验证。

```javascript
// 前端状态管理示例结构
const state = {
  token: localStorage.getItem('TOKEN') || '',
  username: '',
  userId: '',
}

const mutations = {
  setToken(state, token) {
    state.token = token
    localStorage.setItem('TOKEN', token)
  }
}
```

## 4.1.3 个人信息修改的实现

用户在已登录状态下，点击"个人信息"菜单，前端页面会展示用户当前的个人信息，如昵称、头像、性别、邮箱、个人简介等。用户修改信息后，点击"保存"按钮，前端将修改后的信息发送到后端。

**实现步骤**：

1. **前端信息修改请求**（client/src/api/index/user.js）：

```javascript
export const updateApi = function (params, data) {
  return axios({
    url: '/myapp/index/user/update',
    method: 'post',
    headers: {
      'Content-Type': 'multipart/form-data;charset=utf-8'
    },
    params: params,  // 用户ID
    data: data       // 修改的用户信息（包括头像文件）
  })
}
```

2. **后端信息修改处理**（server/myapp/views/index/user.py）：

后端的update方法接收用户ID和修改的用户信息，执行以下操作：
- 根据用户ID查询用户
- 对传入的数据进行验证和过滤（移除不允许修改的字段）
- 验证数据格式（如手机号、邮箱等）
- 处理头像上传
- 更新用户信息到数据库

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def update(request):
    try:
        # 获取用户ID
        pk = request.GET.get('id', -1)
        user = User.objects.get(pk=pk)
    except User.DoesNotExist:
        return APIResponse(code=1, msg='对象不存在')

    # 获取修改数据
    data = request.data.copy()
    
    # 防止修改这些关键字段
    if 'username' in data.keys():
        del data['username']
    if 'password' in data.keys():
        del data['password']
    if 'role' in data.keys():
        del data['role']
    if 'status' in data.keys():
        del data['status']

    # 更新用户信息
    serializer = UserSerializer(user, data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='更新成功', data=serializer.data)
    else:
        print(serializer.errors)

    return APIResponse(code=1, msg='更新失败')
```

**个人信息修改时序图**：

```
用户进入个人信息页面
    ↓
前端调用infoApi获取当前用户信息
    ↓
后端返回用户信息
    ↓
前端显示用户信息表单
    ↓
用户修改信息
    ↓
点击保存按钮
    ↓
前端调用updateApi发送修改
    ↓
后端验证用户身份（Token）
    ↓
数据格式验证 → 过滤敏感字段 → 处理文件上传
    ↓
更新数据库
    ↓
返回更新后的用户信息
    ↓
前端更新界面显示成功
```

## 4.1.4 修改密码的实现

用户可以修改自己的账户密码。点击"修改密码"选项，前端展示原密码、新密码、确认新密码的输入框。用户填入相关信息后，点击"确认修改"，前端调用updatePwdApi方法，将密码信息发送到后端。

**实现步骤**：

1. **前端密码修改请求**（client/src/api/index/user.js）：

```javascript
export const updatePwdApi = function (params, data) {
  return axios({
    url: '/myapp/index/user/updatePwd',
    method: 'post',
    headers: {
      'Content-Type': 'multipart/form-data;charset=utf-8'
    },
    params: params,  // 用户ID
    data: data       // 原密码、新密码、确认新密码
  })
}
```

2. **后端密码修改处理**（server/myapp/views/index/user.py）：

后端的updatePwd方法执行以下操作：
- 根据用户ID查询用户
- 验证原密码是否正确
- 检查新密码和确认密码是否一致
- 对新密码进行MD5加密
- 更新用户密码到数据库

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def updatePwd(request):
    try:
        pk = request.GET.get('id', -1)
        user = User.objects.get(pk=pk)
    except User.DoesNotExist:
        return APIResponse(code=1, msg='对象不存在')

    # 获取密码参数
    password = request.data.get('password', None)  # 原密码
    newPassword1 = request.data.get('newPassword1', None)  # 新密码
    newPassword2 = request.data.get('newPassword2', None)  # 确认新密码

    # 参数验证
    if not password or not newPassword1 or not newPassword2:
        return APIResponse(code=1, msg='不能为空')

    # 验证原密码
    if user.password != utils.md5value(password):
        return APIResponse(code=1, msg='原密码不正确')

    # 检查新密码一致性
    if newPassword1 != newPassword2:
        return APIResponse(code=1, msg='两次密码不一致')

    # 更新密码
    data = request.data.copy()
    data.update({'password': utils.md5value(newPassword1)})  # MD5加密
    serializer = UserSerializer(user, data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='更新成功', data=serializer.data)
    else:
        print(serializer.errors)

    return APIResponse(code=1, msg='更新失败')
```

## 4.1.5 用户列表查询的实现

管理员登录管理界面后，点击"用户管理"菜单，前端调用用户列表查询API向后端发送GET请求。后端返回所有用户信息，前端以表格形式展示用户列表。

**实现步骤**：

1. **后端用户列表查询**（server/myapp/views/admin/user.py）：

```python
@api_view(['GET'])
def list_api(request):
    if request.method == 'GET':
        # 获取搜索关键词
        keyword = request.GET.get("keyword", '')
        
        # 查询用户，支持模糊搜索
        users = User.objects.filter(username__contains=keyword).order_by('-create_time')
        
        # 序列化数据
        serializer = UserSerializer(users, many=True)
        return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

## 4.1.6 用户账号冻结与解冻的实现

管理员登录管理界面后，在用户列表中找到对应用户，点击"冻结"按钮可冻结用户账号，点击"解冻"按钮可解冻用户账号。冻结状态下，该用户无法登录系统。

**实现步骤**：

1. **后端账号冻结/解冻处理**（server/myapp/views/admin/user.py）：

```python
@api_view(['POST'])
@authentication_classes([AdminTokenAuthtication])
def freezeOrUnfreeze(request):
    """
    冻结或解冻用户账号
    """
    if isDemoAdminUser(request):
        return APIResponse(code=1, msg='演示帐号无法操作')
    
    try:
        user_id = request.data.get('id', -1)
        user = User.objects.get(pk=user_id)
    except User.DoesNotExist:
        return APIResponse(code=1, msg='用户不存在')
    
    # 切换账号状态
    current_status = user.status
    new_status = '0' if current_status == '1' else '1'
    
    data = {'status': new_status}
    serializer = UserSerializer(user, data=data)
    if serializer.is_valid():
        serializer.save()
        msg = '已冻结' if new_status == '1' else '已解冻'
        return APIResponse(code=0, msg=msg, data=serializer.data)
    
    return APIResponse(code=1, msg='操作失败')
```

**账号冻结解冻时序图**：

```
管理员进入用户管理页面
    ↓
前端调用list_api获取用户列表
    ↓
后端返回用户列表
    ↓
前端显示用户列表表格
    ↓
管理员点击冻结/解冻按钮
    ↓
前端调用freezeOrUnfreeze方法
    ↓
后端验证管理员身份（AdminToken）
    ↓
检查是否为演示账号 → 查询用户
    ↓
更新用户status字段
    ↓
返回更新后的用户信息
    ↓
前端更新列表显示
```

## 4.1.7 用户账号删除的实现

平台管理员进入用户管理界面，点击用户信息的"删除"按钮，前端调用deleteUserApi方法向后端发送请求。后端根据用户ID删除对应的用户信息。

**实现步骤**：

1. **后端账号删除处理**（server/myapp/views/admin/user.py）：

```python
@api_view(['POST'])
@authentication_classes([AdminTokenAuthtication])
def delete(request):
    """
    删除用户账号及关联数据
    """
    if isDemoAdminUser(request):
        return APIResponse(code=1, msg='演示帐号无法操作')
    
    try:
        user_id = request.data.get('id', -1)
        user = User.objects.get(pk=user_id)
    except User.DoesNotExist:
        return APIResponse(code=1, msg='用户不存在')
    
    # 删除关联数据（级联删除）
    # 删除用户的借阅记录
    Borrow.objects.filter(user=user).delete()
    
    # 删除用户的评论
    Comment.objects.filter(user=user).delete()
    
    # 删除用户的社区帖子
    CommunityPost.objects.filter(user=user).delete()
    
    # 删除用户的地址
    Address.objects.filter(user=user).delete()
    
    # 删除用户
    user.delete()
    
    return APIResponse(code=0, msg='删除成功')
```

**账号删除时序图**：

```
管理员进入用户管理页面
    ↓
前端调用list_api获取用户列表
    ↓
管理员点击删除按钮
    ↓
前端弹出确认对话框
    ↓
用户确认删除
    ↓
前端调用deleteUserApi
    ↓
后端验证管理员身份（AdminToken）
    ↓
检查演示账号限制 → 查询用户
    ↓
级联删除用户相关数据（借阅、评论、帖子、地址等）
    ↓
从数据库删除用户记录
    ↓
返回成功响应
    ↓
前端刷新用户列表
```

---

# 4.2 图书信息管理模块的实现

该部分实现用户查看图书信息、搜索图书、添加到愿望单/收藏，以及管理员进行图书管理的功能。

## 4.2.1 图书列表查询的实现

用户在前端首页可以看到图书列表。前端调用图书列表查询API向后端发送GET请求，后端返回所有上架的图书信息，前端以卡片形式展示图书列表。

**实现步骤**：

1. **前端图书列表请求**（client/src/api/index/book.js）：

```javascript
export const listApi = function (data) {
  return axios({
    url: '/myapp/index/book/list',
    method: 'get',
    params: data  // 包含keyword、classification_id、tag_id、page、limit
  })
}
```

2. **后端图书列表处理**（server/myapp/views/index/book.py）：

后端接收查询参数，执行以下操作：
- 获取所有上架的图书
- 根据关键词进行模糊搜索
- 根据分类ID进行筛选
- 根据标签ID进行筛选
- 按推荐度或浏览量排序
- 进行分页处理

```python
@api_view(['GET'])
def list_api(request):
    """
    获取图书列表
    支持分类、标签、关键词搜索和排序
    """
    # 获取查询参数
    keyword = request.GET.get('keyword', '')
    classification_id = request.GET.get('classification_id', '')
    tag_id = request.GET.get('tag_id', '')
    page = request.GET.get('page', 1)
    limit = request.GET.get('limit', 10)
    
    # 查询上架的图书
    books = Book.objects.filter(status='0')
    
    # 关键词搜索
    if keyword:
        books = books.filter(
            Q(title__contains=keyword) | 
            Q(author__contains=keyword) |
            Q(description__contains=keyword)
        )
    
    # 分类筛选
    if classification_id:
        books = books.filter(classification_id=classification_id)
    
    # 标签筛选
    if tag_id:
        books = books.filter(tag__id=tag_id).distinct()
    
    # 按推荐度排序
    books = books.order_by('-recommend_count', '-pv')
    
    # 分页处理
    start = (int(page) - 1) * int(limit)
    end = start + int(limit)
    books_page = books[start:end]
    
    # 序列化数据
    serializer = ListBookSerializer(books_page, many=True)
    return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

## 4.2.2 图书详情查询的实现

用户点击图书卡片进入图书详情页面，前端调用图书详情API，后端返回完整的图书信息及相关评论。

**实现步骤**：

1. **前端图书详情请求**（client/src/api/index/book.js）：

```javascript
export const detailApi = function (data) {
  return axios({
    url: '/myapp/index/book/detail',
    method: 'get',
    params: data  // book_id
  })
}
```

2. **后端图书详情处理**：

后端接收图书ID，执行以下操作：
- 查询对应的图书信息
- 增加图书的浏览量(pv)
- 获取图书的相关评论
- 获取图书的推荐信息

```python
@api_view(['GET'])
def detail(request):
    """
    获取图书详情
    """
    book_id = request.GET.get('book_id', -1)
    
    try:
        book = Book.objects.get(pk=book_id)
    except Book.DoesNotExist:
        return APIResponse(code=1, msg='图书不存在')
    
    # 增加浏览量
    book.pv += 1
    book.save()
    
    # 序列化数据
    serializer = DetailBookSerializer(book)
    return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

## 4.2.3 图书搜索的实现

用户在前端搜索框输入图书名称或作者名，点击"搜索"按钮，前端将查询条件发送到后端。后端根据关键词进行搜索，返回符合条件的图书列表。

**实现步骤**：

1. **前端搜索请求**：

```javascript
// 前端搜索方法
searchBooks(keyword) {
  listApi({
    keyword: keyword,
    page: 1,
    limit: 10
  }).then(response => {
    if (response.code === 0) {
      this.bookList = response.data
    }
  })
}
```

2. **后端搜索处理**：

后端的listApi方法已包含了搜索功能，使用关键词对图书标题、作者、描述进行模糊匹配。

**图书搜索时序图**：

```
用户进入首页
    ↓
前端调用listApi获取图书列表
    ↓
后端查询上架图书 → 应用分类/标签筛选
    ↓
按推荐度排序 → 分页处理
    ↓
序列化图书数据返回
    ↓
前端显示图书列表
    ↓
用户输入搜索关键词
    ↓
点击搜索按钮
    ↓
前端调用listApi(keyword=xxx)
    ↓
后端模糊搜索 → 返回匹配的图书
    ↓
前端刷新显示搜索结果
```

## 4.2.4 添加到愿望单的实现

用户查看图书详情后，可以点击"添加到愿望单"按钮，将图书添加到个人的愿望单列表。

**实现步骤**：

1. **前端添加愿望单请求**（client/src/api/index/book.js）：

```javascript
export const addWishUserApi = function (data) {
  return axios({
    url: '/myapp/index/book/addWishUser',
    method: 'post',
    params: data  // book_id
  })
}
```

2. **后端添加愿望单处理**：

后端验证用户身份，将用户添加到图书的wish多对多关系中，并增加wish_count计数。

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def addWishUser(request):
    """
    用户添加图书到愿望单
    """
    book_id = request.GET.get('book_id', -1)
    user = request.user  # 从Token获取当前用户
    
    try:
        book = Book.objects.get(pk=book_id)
    except Book.DoesNotExist:
        return APIResponse(code=1, msg='图书不存在')
    
    # 检查是否已添加
    if book.wish.filter(pk=user.id).exists():
        return APIResponse(code=1, msg='已添加到愿望单')
    
    # 添加用户到愿望单
    book.wish.add(user)
    book.wish_count += 1
    book.save()
    
    return APIResponse(code=0, msg='添加成功')
```

## 4.2.5 添加收藏的实现

用户可以收藏喜欢的图书，点击"收藏"按钮后，图书被添加到用户的收藏列表。

**实现步骤**：

1. **前端添加收藏请求**（client/src/api/index/book.js）：

```javascript
export const addCollectUserApi = function (data) {
  return axios({
    url: '/myapp/index/book/addCollectUser',
    method: 'post',
    params: data  // book_id
  })
}
```

2. **后端添加收藏处理**：

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def addCollectUser(request):
    """
    用户收藏图书
    """
    book_id = request.GET.get('book_id', -1)
    user = request.user
    
    try:
        book = Book.objects.get(pk=book_id)
    except Book.DoesNotExist:
        return APIResponse(code=1, msg='图书不存在')
    
    # 检查是否已收藏
    if book.collect.filter(pk=user.id).exists():
        return APIResponse(code=1, msg='已收藏')
    
    # 添加收藏
    book.collect.add(user)
    book.collect_count += 1
    book.save()
    
    return APIResponse(code=0, msg='收藏成功')
```

## 4.2.6 获取愿望单列表的实现

用户可以查看自己的愿望单列表，了解想要阅读的图书。

**实现步骤**：

1. **前端愿望单列表请求**（client/src/api/index/book.js）：

```javascript
export const getWishBookListApi = function (params) {
  return axios({
    url: '/myapp/index/book/getWishBookList',
    method: 'get',
    params: params  // page、limit
  })
}
```

2. **后端愿望单列表处理**：

```python
@api_view(['GET'])
@authentication_classes([TokenAuthtication])
def getWishBookList(request):
    """
    获取用户的愿望单图书列表
    """
    user = request.user
    page = request.GET.get('page', 1)
    limit = request.GET.get('limit', 10)
    
    # 获取用户的愿望单图书
    wish_books = user.wish_books.all()
    
    # 分页处理
    start = (int(page) - 1) * int(limit)
    end = start + int(limit)
    wish_books_page = wish_books[start:end]
    
    # 序列化数据
    serializer = ListBookSerializer(wish_books_page, many=True)
    return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

## 4.2.7 获取收藏列表的实现

用户可以查看自己的收藏图书列表。

**实现步骤**：

1. **前端收藏列表请求**（client/src/api/index/book.js）：

```javascript
export const getCollectBookListApi = function (params) {
  return axios({
    url: '/myapp/index/book/getCollectBookList',
    method: 'get',
    params: params  // page、limit
  })
}
```

2. **后端收藏列表处理**：

```python
@api_view(['GET'])
@authentication_classes([TokenAuthtication])
def getCollectBookList(request):
    """
    获取用户的收藏图书列表
    """
    user = request.user
    page = request.GET.get('page', 1)
    limit = request.GET.get('limit', 10)
    
    # 获取用户的收藏图书
    collect_books = user.collect_books.all()
    
    # 分页处理
    start = (int(page) - 1) * int(limit)
    end = start + int(limit)
    collect_books_page = collect_books[start:end]
    
    # 序列化数据
    serializer = ListBookSerializer(collect_books_page, many=True)
    return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

---

# 4.3 借阅管理模块的实现

该部分实现用户借阅图书、还书、延期等功能，以及管理员查看和管理借阅记录的功能。

## 4.3.1 创建借阅的实现

用户在图书详情页点击"借阅"按钮，前端弹出借阅信息表单（选择收货地址、填写备注等）。用户填入信息后点击"确认借阅"，前端调用createBorrowApi方法发送借阅请求到后端。

**实现步骤**：

1. **前端创建借阅请求**（client/src/api/index/borrow.js）：

```javascript
export const createBorrowApi = function (data) {
  return axios({
    url: '/myapp/index/borrow/create',
    method: 'post',
    params: data  // book_id、address_id
  })
}
```

2. **后端创建借阅处理**：

后端接收借阅请求，执行以下操作：
- 验证用户身份
- 查询图书信息
- 检查图书库存
- 计算应还时间
- 创建借阅记录
- 扣减图书库存

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def create(request):
    """
    用户创建借阅
    """
    book_id = request.GET.get('book_id', -1)
    address_id = request.GET.get('address_id', -1)
    user = request.user
    
    try:
        book = Book.objects.get(pk=book_id)
        address = Address.objects.get(pk=address_id)
    except:
        return APIResponse(code=1, msg='图书或地址不存在')
    
    # 检查库存
    if book.repertory <= 0:
        return APIResponse(code=1, msg='图书库存不足')
    
    # 创建借阅记录
    borrow_time = datetime.datetime.now()
    expect_time = borrow_time + datetime.timedelta(days=30)  # 30天后应还
    
    data = {
        'user': user.id,
        'book': book.id,
        'borrow_time': borrow_time,
        'expect_time': expect_time,
        'status': '1',  # 借阅中
    }
    
    serializer = BorrowSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        
        # 扣减库存
        book.repertory -= 1
        book.save()
        
        return APIResponse(code=0, msg='借阅成功', data=serializer.data)
    
    return APIResponse(code=1, msg='借阅失败')
```

## 4.3.2 借阅列表查询的实现

用户可以查看自己的所有借阅记录（包括借阅中和已归还）。

**实现步骤**：

1. **后端借阅列表处理**：

```python
@api_view(['GET'])
@authentication_classes([TokenAuthtication])
def list_api(request):
    """
    获取用户的借阅记录列表
    """
    user = request.user
    status = request.GET.get('status', '')  # 可选筛选状态
    page = request.GET.get('page', 1)
    limit = request.GET.get('limit', 10)
    
    # 获取用户的借阅记录
    borrows = Borrow.objects.filter(user=user)
    
    # 按状态筛选
    if status:
        borrows = borrows.filter(status=status)
    
    # 按时间倒序排列
    borrows = borrows.order_by('-borrow_time')
    
    # 分页处理
    start = (int(page) - 1) * int(limit)
    end = start + int(limit)
    borrows_page = borrows[start:end]
    
    # 序列化数据
    serializer = BorrowSerializer(borrows_page, many=True)
    return APIResponse(code=0, msg='查询成功', data=serializer.data)
```

## 4.3.3 还书的实现

用户在借阅列表中点击"还书"按钮，前端调用还书API，后端更新借阅记录状态，恢复图书库存。

**实现步骤**：

1. **后端还书处理**：

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def return_book(request):
    """
    用户还书
    """
    borrow_id = request.GET.get('borrow_id', -1)
    
    try:
        borrow = Borrow.objects.get(pk=borrow_id)
    except Borrow.DoesNotExist:
        return APIResponse(code=1, msg='借阅记录不存在')
    
    # 检查借阅状态
    if borrow.status == '2':
        return APIResponse(code=1, msg='已归还，无需重复还书')
    
    # 更新借阅状态
    data = {
        'status': '2',  # 已归还
        'return_time': datetime.datetime.now(),
    }
    
    serializer = BorrowSerializer(borrow, data=data)
    if serializer.is_valid():
        serializer.save()
        
        # 恢复图书库存
        book = borrow.book
        book.repertory += 1
        book.save()
        
        return APIResponse(code=0, msg='还书成功', data=serializer.data)
    
    return APIResponse(code=1, msg='还书失败')
```

## 4.3.4 延期的实现

用户可以延期已借出的图书。点击"延期"按钮，后端延长应还时间。

**实现步骤**：

1. **后端延期处理**：

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def delay(request):
    """
    用户延期借阅
    """
    borrow_id = request.GET.get('borrow_id', -1)
    
    try:
        borrow = Borrow.objects.get(pk=borrow_id)
    except Borrow.DoesNotExist:
        return APIResponse(code=1, msg='借阅记录不存在')
    
    # 检查是否已延期
    if borrow.delayed == True:
        return APIResponse(code=1, msg='已延期过，不能再延期')
    
    # 检查是否逾期
    if datetime.datetime.now() > borrow.expect_time:
        return APIResponse(code=1, msg='已逾期，不能延期')
    
    # 延长应还时间（延期7天）
    new_expect_time = borrow.expect_time + datetime.timedelta(days=7)
    
    data = {
        'expect_time': new_expect_time,
        'delayed': True,
    }
    
    serializer = BorrowSerializer(borrow, data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='延期成功', data=serializer.data)
    
    return APIResponse(code=1, msg='延期失败')
```

---

# 4.4 社区互动模块的实现

该部分实现用户发表帖子、评论、点赞等社区交互功能。

## 4.4.1 发表帖子的实现

用户点击"发表帖子"按钮，前端弹出编辑框供用户输入帖子标题和内容。用户点击"发表"后，前端调用发表帖子API，后端创建帖子记录。

**实现步骤**：

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def createPost(request):
    """
    用户发表社区帖子
    """
    user = request.user
    
    # 获取帖子信息
    title = request.data.get('title', '')
    content = request.data.get('content', '')
    
    if not title or not content:
        return APIResponse(code=1, msg='标题和内容不能为空')
    
    # 创建帖子
    data = {
        'title': title,
        'content': content,
        'user': user.id,
        'pv': 0,
        'like_count': 0,
    }
    
    serializer = CommunityPostSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='发表成功', data=serializer.data)
    
    return APIResponse(code=1, msg='发表失败')
```

## 4.4.2 评论图书的实现

用户在图书详情页可以发表评论。前端调用发表评论API，后端创建评论记录。

**实现步骤**：

```python
@api_view(['POST'])
@authentication_classes([TokenAuthtication])
def createComment(request):
    """
    用户发表图书评论
    """
    user = request.user
    book_id = request.GET.get('book_id', -1)
    content = request.data.get('content', '')
    
    if not content:
        return APIResponse(code=1, msg='评论内容不能为空')
    
    try:
        book = Book.objects.get(pk=book_id)
    except Book.DoesNotExist:
        return APIResponse(code=1, msg='图书不存在')
    
    # 检查是否已评论
    existing = Comment.objects.filter(user=user, book=book)
    if existing.exists():
        return APIResponse(code=1, msg='已评论，一个用户只能评论一次')
    
    # 创建评论
    data = {
        'content': content,
        'user': user.id,
        'book': book.id,
        'comment_time': datetime.datetime.now(),
        'like_count': 0,
    }
    
    serializer = CommentSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='评论成功', data=serializer.data)
    
    return APIResponse(code=1, msg='评论失败')
```

---

# 4.5 系统管理模块的实现

该部分实现系统管理员对广告、横幅、通知、活动等平台资源的管理功能。

## 4.5.1 广告管理的实现

管理员可以上传广告图片、设置广告链接。

**实现步骤**：

```python
@api_view(['POST'])
@authentication_classes([AdminTokenAuthtication])
def createAd(request):
    """
    管理员创建广告
    """
    if isDemoAdminUser(request):
        return APIResponse(code=1, msg='演示帐号无法操作')
    
    # 获取广告信息
    image = request.FILES.get('image', None)
    link = request.data.get('link', '')
    
    if not image or not link:
        return APIResponse(code=1, msg='图片和链接不能为空')
    
    # 创建广告
    data = {
        'image': image,
        'link': link,
    }
    
    serializer = AdSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='创建成功', data=serializer.data)
    
    return APIResponse(code=1, msg='创建失败')
```

## 4.5.2 通知管理的实现

管理员可以创建、编辑、删除平台通知。

**实现步骤**：

```python
@api_view(['POST'])
@authentication_classes([AdminTokenAuthtication])
def createNotice(request):
    """
    管理员创建通知
    """
    if isDemoAdminUser(request):
        return APIResponse(code=1, msg='演示帐号无法操作')
    
    # 获取通知信息
    title = request.data.get('title', '')
    content = request.data.get('content', '')
    
    if not title or not content:
        return APIResponse(code=1, msg='标题和内容不能为空')
    
    # 创建通知
    data = {
        'title': title,
        'content': content,
    }
    
    serializer = NoticeSerializer(data=data)
    if serializer.is_valid():
        serializer.save()
        return APIResponse(code=0, msg='创建成功', data=serializer.data)
    
    return APIResponse(code=1, msg='创建失败')
```

## 4.5.3 系统数据统计的实现

管理员可以查看系统的统计信息，包括用户总数、图书总数、借阅总数等。

**实现步骤**：

```python
@api_view(['GET'])
@authentication_classes([AdminTokenAuthtication])
def overviewCount(request):
    """
    获取系统数据统计
    """
    user_count = User.objects.count()
    book_count = Book.objects.count()
    borrow_count = Borrow.objects.count()
    comment_count = Comment.objects.count()
    post_count = CommunityPost.objects.count()
    
    data = {
        'user_count': user_count,
        'book_count': book_count,
        'borrow_count': borrow_count,
        'comment_count': comment_count,
        'post_count': post_count,
    }
    
    return APIResponse(code=0, msg='查询成功', data=data)
```

---

## 附录 - API响应格式说明

系统所有API都返回统一的APIResponse格式：

```python
class APIResponse:
    """
    统一的API响应格式
    """
    def __init__(self, code=0, msg='', data=None):
        self.code = code  # 响应码：0表示成功，其他表示失败
        self.msg = msg    # 响应信息
        self.data = data  # 响应数据
```

**返回示例**：

```json
// 成功响应
{
  "code": 0,
  "msg": "操作成功",
  "data": {
    "id": 1,
    "username": "user@example.com",
    "nickname": "张三"
  }
}

// 失败响应
{
  "code": 1,
  "msg": "用户名或密码错误",
  "data": null
}
```

---

## 认证机制说明

系统使用Token认证机制确保API安全：

### 前台用户认证（TokenAuthentication）

- 用户登录成功后，后端生成Token = MD5(username)
- 前端将Token存储在localStorage中
- 所有后续请求都在请求头中添加：`token: {user_token}`
- 后端TokenAuthentication类验证Token有效性

### 后台管理员认证（AdminTokenAuthentication）

- 管理员登录成功后，后端生成AdminToken = MD5(admin_username)
- 所有后续请求都在请求头中添加：`adminToken: {admin_token}`
- 后端AdminTokenAuthentication类验证AdminToken有效性

### 演示账号限制

对于演示账号（role='2'），部分操作被限制：
- 无法删除用户
- 无法修改他人信息
- 无法删除图书
- 无法修改系统配置等

---

## 错误处理说明

系统采用统一的错误处理机制：

1. **参数验证错误**：返回code=1，msg="参数缺失或格式错误"
2. **数据库查询错误**：返回code=1，msg="对象不存在"
3. **业务逻辑错误**：返回code=1，msg="具体错误信息"
4. **认证失败**：返回code=1，msg="身份验证失败"
5. **权限不足**：返回code=1，msg="权限不足"

前端根据响应码和消息进行相应的处理：
- code=0：显示成功提示，更新UI
- code=1：显示错误提示，保留当前状态

---

**文档完成** ✓
